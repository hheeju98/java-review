package ex01;

// 0~22년도 
// 0~끝까지 (static) 메모리 많이 잡아먹음
// 1999년 ~~죽을때까지(heap) 동적임
// 메모리 관리를 위해 나눔
// 스택 = 행위가 시작될때 메모리에 뜨는것 - 재민 성현 공격  싸움 끝나면 기억 안함
// 다리를 이렇게 해서 맞았구나 기억하고 싶으면 힙으로 옮긺 오래 기억하고 싶을때
// 책한번 보면 스택 장기기억은 힙 
// 스택은 행위가 있을때 뜬다
// heap, stack, static(클래스 종속 키워드) 클래스내부가 아니면 못쓴다.

class Lion {
    // 행위만 있는건 객체가 아님 함수형 프로그램일 뿐임 상태가 없다
    private int 배상태 = 0;

    public int get배상태() {
        return 배상태;
    }

    public void eat() { // 재귀메서드

        int happy = 0; // 메서드 내부에 있어서 지역변수 메서드가 들고있어서 상태가 아님
        배상태++;
        happy = happy + 20;
        // 끝나면 행복은 사라져 버린다
        // 배상태는 그래고 2가됨
        // eat은 한번 호출에 4바이트 행복이 4바이트짜리
        // 메서드 행위가 일어나는건 다 단기기억 행위를 할 때만

        if (배상태 >= 100) {

        } else {
            eat();
        }
        // 스택이 안 닫히고 변수 초기화 행복두개가 만들어짐 계속 스택이 늘어난다. 4 바이트 씩 늘어나서
        // 스택 용량의 한계가 온다. 그게 스택오버플로우에러 스택이 스택을 호출하는 구조에서 스택이 터진다.스택이 닫히지 않았다는 뜻
        // 자기가 자기를 호출 = 제귀메서드

    }
}

public class StackOverFlowEx01 {
    // 사자를 메모리에 띄울 책임이 있는 애가 없으면 메인에서 띄운다
    // 메인은 컨택스트를 가진다.
    // run이 실행되면 모든 정보를 돌려줌
    public static void main(String[] args) {
        Lion lion = new Lion();
        // new는 static이 아닌 모든것을 띄운다
        // lion.배상태 = 1111111; 될 수 있으므로 백프로 상태 행위통한 변경 보장 못함 private
        lion.eat();
        System.out.println("아 배불러 : " + lion.get배상태());
    }
}
